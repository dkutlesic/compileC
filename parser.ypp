%{
    using namespace std;
    #include<iostream>
    #include<cstdlib>
    #include<string>
    #include<map>
    #include<vector>
    #include<set>

    extern int yylex();

    void yyerror(const string& err){
        cerr<<"Error: "<<err<<endl;
        exit(EXIT_FAILURE);
    }

    string output;
    map<string, int> variables;
    set<string> functions;

    #define YYDEBUG 1
%}

%union{
    int num;
    string* id;
}

%token <id> IF_TOKEN ELSE_TOKEN WHILE_TOKEN
%token <id> INC_TOKEN DEC_TOKEN
%token <id> EQUAL_TOKEN
%token <id> INT_TOKEN RETURN_TOKEN MAIN_TOKEN
%token <num> NUM_TOKEN
%token <id> ID_TOKEN function_header 

%right '='
%left '+' '-'
%left '*' '/'
%token UMINUS

%%

program : definitions main {
    cout<<"start parse"<<endl;  
};

definitions : definitions int_function {
            
        } | {

};

int_function : function_header '{' instruction_array RETURN_TOKEN expression ';' '}' {
    
};

function_header : INT_TOKEN ID_TOKEN '(' parameter_list ')' {
    functions.insert(*$2);
    $$ = new string((*$1) + (*$2));
    output += *$2 + ":\n";
        } | INT_TOKEN ID_TOKEN '(' ')' {
    functions.insert(*$2);
    output += *$2 + ":\n";

};

parameter_list : parameter_list ',' INT_TOKEN ID_TOKEN {

        } | INT_TOKEN ID_TOKEN {

};

main : INT_TOKEN MAIN_TOKEN '(' ')' '{' instruction_array '}' {
    cout<<"main"<<endl;
    output += "MAIN:\n";
};

instruction_array : instruction_array instruction {

        } | {
    
};

instruction : assignment ';' {

        } | if_instruction {
    cout<<"If instruction"<<endl;
        } | if_else_instruction {
    cout<<"If else instruction"<<endl;
        } | while_instruction {
    cout<<"while instruction"<<endl;
        } | expression ';' {
};

assignment : INT_TOKEN ID_TOKEN '=' expression {
    cout<<"new assignment"<<endl;
        } | ID_TOKEN '=' expression {
    cout<<"assignment"<<endl;
};

expression : value {
    cout<<"value"<<endl;
        } | ID_TOKEN INC_TOKEN {
    cout<<"x++"<<endl;
    //try w/o specific class -> use assign and expression
        } | INC_TOKEN ID_TOKEN {
    cout<<"++x"<<endl;
        } | ID_TOKEN DEC_TOKEN {
    cout<<"x--"<<endl;
        } | DEC_TOKEN ID_TOKEN {
    cout<<"--x"<<endl;
        } | '-' expression %prec UMINUS {
    cout<<"unary minus"<<endl;
        } | expression '+' expression {
    cout<<"+"<<endl;
        } | expression '-' expression {
    cout<<"-"<<endl;
        } | expression '*' expression {
    cout<<"*"<<endl;
        } | expression '/' expression {
    cout<<"/"<<endl;
        } '(' expression ')' {
    cout<<"( )"<<endl;
        } | apply_function {
};

value : NUM_TOKEN {

    } | ID_TOKEN {

    } | apply_function {

};

if_instruction : IF_TOKEN '(' condition ')' '{' instruction_array '}' {

};

if_else_instruction : IF_TOKEN '(' condition ')' '{' instruction_array '}' ELSE_TOKEN '{' instruction_array '}' {

};

while_instruction : WHILE_TOKEN '(' condition ')' '{' instruction_array '}' {

};

condition : expression '<' expression {
    cout<<"less"<<endl;
        } | expression '>' expression {
    cout<<"great"<<endl;
        } | expression EQUAL_TOKEN expression {
    cout<<"equal equal"<<endl;
};

apply_function : ID_TOKEN '(' apply_list ')' {
    if(functions.find(*$1) == functions.end()){
        cout <<"Function " << *$1 << " is not defined." << endl;
        exit(EXIT_FAILURE);
    }
    output += "CALL " + *$1 + "\n";
} | ID_TOKEN '(' ')' {
      if(functions.find(*$1) == functions.end()){
        cout <<"Function " << *$1 << " is not defined." << endl;
        exit(EXIT_FAILURE);
    }
    output += "CALL " + *$1 + "\n";
};

apply_list : apply_list ',' value {

        } | value {

};

%%

int main(){
    cout<<"start"<<endl;
    yydebug = 1;
    yyparse();
    for(auto &name: functions) {
        cout << name << endl;
    }
    cout<<output<<endl;
    return 0;
}